## Use of the Book

- Chapter 1: contains motivational material and presents some background issues in computer architecture and programming-language principles
- Chapter 2: develops a miniature compiler and introduces many of the important concepts, which are then developed in later chapters
- Chapter 3: covers lexical analysis, regular expressions, finite-state machines, and scanner-generator tools (the material is fundamental to text-processing of all sorts)
- Chapter 4: covers the major parsing methods, top-down (recursive-descent, LL) and bottom-up (LR and its variants)
- Chapter 5: introduces the principal ideas in syntax-directed definitions and syntax-directed translations
- Chapter 6: takes the theory of Chapter 5 and shows how to use it to generate intermediate code for a typical programming language
- Chapter 7: covers run-time environments, especially management of the run-time stack and garbage collection
- Chapter 8: on object-code generation, covers construction of basic blocks, generation of code from expressions and basic blocks, and register-allocation techniques
- Chapter 9: introduces the technology of code optimization, including flow graphs, data-flow frameworks, and iterative algorithms for solving these frameworks
- Chapter 10: covers instruction-level optimization. the emphasis is on the extraction of parallelism from small sequences of instructions and scheduling them on single processors that can do more than one thing at once
- Chapter 11: talks about larger-scale parallelism detection and exploitation. the emphasis is on numeric codes that have many tight loops that range over multidimensional arrays
- Chapter 12: is on interprocedural analysis. it covers pointer analysis, aliasing, and data-flow analysis that takes into account the sequence of procedure calls that reach a given point in the code

[homepage](http://dragonbook.stanford.edu)
