# 7. 通讯

- 介绍Go中与外部通讯的通讯模块
- 了解文件、目录、网络通讯和运行其他程序

I/O核心是接口`io.Reader`和`io.Writer`

- 使用os包就能从文件`/etc/passwd`中读取数据

```go
// 从文件读取（无缓冲）
package main

import "os"

func main() {
    buf := make([]byte, 1024)
    f, _ := os.Open("/etc/passwd") // 打开文件，os.Open返回一个实现了io.Reader和io.Writer的*os.File
    defer f.Close() // 确保关闭了f
    for {
        n, _ := f.Read(buf) // 一次读取1024字节
        if n==0 {break} // 到达文件末尾
        os.Stdout.Write(buf[:n]) // 将内容写入os.Stdout
    }
}
```

- 如果想要使用缓冲IO，则有bufio包

```go
// 从文件读取（缓冲）
package main

import (
    "os"
    "bufio"
)

func main() {
    buf := make([]byte, 1024)
    f, _ := os.Open("/etc/passwd") // 打开文件
    defer f.Close()
    r := bufio.NewReader(f) // 转换f为有缓冲的Reader. NewReader需要一个io.Reader，但是不会出错，因为任何有Read()函数就实现了这个接口
    w := bufio.NewWriter(os.Stdout)
    defer w.Flush()
    for {
        n, _ := r.Read(buf) // 从Reader读取，向Writer写入，然后向屏幕输出文件
        if n == 0 {break}
        w.Write(buf[0:n])
        }
}
```

### io.Reader

- 许多函数需要通过io.Reader读取一些数据作为输入
- 为了满足这个接口，需要实现一个方法：`Read(p []byte) (n int, err error)`
- 写入则需要实现Write方法的io.Writer
- 如果你自己的程序或包中的类型实现了io.Reader或io.Writer接口，那么整个Go标准库都能使用这个类型

### 一些例子

- 一行一行地读取

```go
f, _ := os.Open("/etc/passwd")
defer f.Close()
r := bufio.NewReader(f) //使其成为一个bufio，以便访问ReadString方法
s, ok := r.ReadString('\n') { // 从输入中读取一行
    // ... // s保存了字符串，通过string包就可以解析它
}
```

- 更通用的方法是ReadLine
- 在shell脚本中通常遇到的场景是需要检查某个目录是否存在。如果不存在，就创建一个

```bash
# 用shell创建一个目录
if [! -e name ]; then
    mkdir name
else
    # error
fi
```

### 命令行参数

### 执行命令

### 网络

### 练习

### 答案
