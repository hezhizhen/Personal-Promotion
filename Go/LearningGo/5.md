# 5. 接口

每个类型都有接口，即对那个类型定义了方法集合

```go
type S struct {i int}
func (p *S) Get() int {return p.i}
func (p *S) Put(v int) {p.i = v}
```

定义了具有一个字段和两个方法的结构类型S

```go
type I interface{
    Get() int
    Put(int)
}
```

定义接口类型，仅仅是方法的集合。上述定义了一个有两个方法的接口I

对于接口I，S是合法的实现，因为它定义了I所需的两个方法（即使没有明确定义S实现了I，也是正确的）

```go
func f(p I) { // 定义一个函数接受一个接口类型作为参数
    fmt.Println(p.Get())// p实现了接口I，必须有Get()方法，同样也要有Put()方法
    p.Put(1)
}
```

接口值。变量p保存了接口类型的值

```go
var s S
f(&s)
```

因为S实现了接口I，可以调用f向其传递S类型的值的指针。获取s的地址而非S的值的原因，是在s的指针上定义了方法

无须明确一个类型是否实现了一个接口。Go实现了叫做duck typing的模式，如果可能的话Go编译器将对类型是否实现了接口进行实现静态检查

```go
type R struct {i int}
func (p *R) Get() int {return p.i}
func (p *R) Put(v int) {p.i = v}
```

定义另外一个类型R，同样实现了接口I。函数f现在可以接受类型为R或S的变量。假设需要在函数f中灰姑娘知道实际的类型，在Go中可以使用`type switch`得到

```go
func f(p I) {
    switch t := p.(type) { //类型判断。使用(type)，保存类型到变量t
    case *S://p的实际类型是S的指针
    case *R:
    case S:
    case R:
    default://实现了I的其他类型
    }
}
```

在switch之外使用`(type)`是非法的。类型判断不是唯一的运行时得到类型的方法。为了在运行时得到类型，同样可以使用`comma,ok`来判断一个接口类型是否实现了某个特定接口

```go
if t,ok := something.(I); ok {
    //对于某些实现了接口I的
    //t是其所拥有的类型
}
```

确定一个变量实现了某个接口，可以使用`t:=something.(I)`

由于每个类型都能匹配到空接口`interface{}`，可以创建一个接受空接口作为参数的普通函数

```go
func g(something interface{}) int {
    return something.(I).Get()
}
```

值`something`具有类型`interface{}`，这意味着方法没有任何约束：它能包含任何类型。`.(I)`是类型断言，用于转换something到I类型的接口。如果有这个类型，则可以调用`Get()`函数。因此，如果创建一个`*S`类型的新变量，也可以调用`g()`，因为`*S`同样实现了空接口

```go
s = new(S)
fmt.Println(g(s))
```

### 方法

### 接口名字

### 简短的例子

### 练习

### 答案
