# [Go指南](https://tour.go-zh.org/welcome/1)

## 欢迎

### Hello，世界

## 包、变量和函数

### 包

程序运行的入口是包main

### 导入

分组导入

### 导出名

首字母大写的名称被导出

只能访问导入包所导出的名字

### 函数

可以有0或多个参数

类型在变量名之后

同类型的连续变量可仅保留最后变量的类型

### 多值返回

函数可以返回任意数量的返回值

多返回值时，用小括号将多个返回值的类型括起来

### 命名返回值

返回值可以被命名，在返回值的类型前加上返回值的变量名

没有参数的return返回各返回变量的当前值（裸返回）

### 变量

var定义变量列表：变量名在前，类型在后

### 初始化变量

如果初始化是使用表达式，则可以省略类型

### 短声明变量

`:=`不能用在函数外，函数外的每个语句必须以关键字开始

### 基本类型

- bool
- string
- int int8 int16 int32 int64
- uint
- byte(uint8)
- rune(uint32)
- float32
- complex64

### 零值

没有明确初始化的变量在定义时会赋零值

- 数值：0
- 布尔值：0
- 字符串：空字符串

### 类型转换

表达式`T(v)`将值v转换为类型T

显式转换

### 类型推导

定义变量但没有显式指定类型时由右侧的值推导出变量的类型

### 常量

使用const关键字

常量不能使用`:=`定义

### 数值常量

数值常量是高精度的值

## 流程控制语句：for、if、else、switch和defer

### for

包含3个由分号分开的组成部分：初始化语句，循环条件表达式，后置语句。不需要用括号括起来，但是循环体必须用`{}`括起来

其中，初始化语句和后置语句不是必需的，可以省略

### for是Go的while

for可以省略分号，就像while一样，只有循环条件表达式

### 死循环

更简洁的形式

```Go
for {
}
```

### if

if的条件也不必括起来

### if的便捷语句

if语句可以在条件之前执行一个简单语句，后接分号；其变量的作用域仅在if范围之内

### if和else

在if中快捷语句中定义的变量同样在对应的else块中使用

### switch

除非以fallthrough语句结束，否则分支会自动终止

### switch的执行顺序

条件从上到下执行，匹配成功时停止

### 没有条件的switch

没有条件的switch同switch true一样

以更清晰的形式来编写长的if-then-else链

### defer

defer会延迟函数的执行直到上层函数返回

延迟调用的参数会立即生成，但是在上层函数返回前函数都不会被调用

### defer栈

延迟的函数调用被压入栈中，当函数返回时，按照后进先出的顺序调用被延迟的函数调用

## 复杂类型：struct、slice和map

### 指针

指针保存在变量的内存地址。零值为nil

`var p *T`定义一个指向类型T的值的指针

`p := &i`生成一个指向i的指针

`*p`表示指针指向的底层的值，即间接引用，或非直接引用

Go没有指针运算

### 结构体

一个字段的集合，以关键字type开始

### 结构体字段

结构体字段使用点号`.`来访问

### 结构体指针

`p := &v`(v是一个结构体)，可以通过`p.X`的形式访问v的字段X

### 结构体文法

通过结构体字段的值作为列表来新分配一个结构体

使用`Name:`语法可以仅列出部分字段（顺序无关），其余字段以零值补

前缀`&`返回一个指向结构体的指针

### 数组

`[n]T`有n个类型为T的值的数组

### slice

一个slice会指向一个序列的值，并且包含了长度信息

`[]T`是一个元素类型为T的slice

`len(s)`会返回slice s的长度

### slice的slice

slice可以包含任意的类型，包括另一个slice

### 对slice切片

`s[lo:hi]`表示从lo到hi-1的slice元素，含前端，不含后端

`s[lo:lo]`是空的

### 构造slice

由函数make创建，分配一个全是零值的数组并返回一个slice指向该数组

`a := make([]int, 5)` 长度为5

`a := make([]int, 0, 5)` 长度为0，容量为5

### nil slice

slice的零值是nil，长度和容量都是0

### 向slice添加元素

内建函数`append`

```Go
var a []int
a = append(a,0)
```

append的第一个参数s是一个元素类型为T的slice，其余类型为T的值会附加到该slice的末尾；返回一个包含原slice所有元素加上新添加的元素的slice

如果s的底层数组太小时，会分配一个更大的数组，返回的slice会指向这个新分配的数组

### range

for循环的range格式可以对slice或map进行迭代循环

当使用for循环遍历一个slice时，每次迭代range会返回2个值：第1个值是当前下标，第2个值是该下标对应元素的一个拷贝

可以通过赋值给`_`来忽略序号或值

### map

map映射键到值。map在使用前必须用make来创建；值为nil的map是空的，并且不能对其赋值

### map的文法

类似结构体，不过必须有键名

若顶级类型只是一个类型名，可以在文法的元素中省略它

### 修改map

- 插入/修改：`m[key] = elem`
- 获得元素：`elem = m[key]`
- 删除元素：`delete(m, key)`
- 通过双赋值检测某个键存在：`elem, ok = m[key]` (如果key在m中，ok为true，否则为false，并且elem为map的元素类型的零值)

### 函数值

函数也是值，可以像值一样传递，比如作为函数的参数或返回值

### 函数的闭包（？）

函数可以是一个闭包。闭包是一个函数值，引用了函数体之外的变量。这个函数可以对这个引用的变量进行访问和赋值，即该函数被绑定在了此变量上

```Go
package main
import "fmt"
func adder() func(int) int {
    sum := 0
    return func(x int) int {
        sum += x
        return sum
    }
}
func main() {
    pos, neg := adder(), adder()
    for i:=0;i<10;i++ {
        fmt.Println(
            pos(i),
            neg(-2*i),
        )
    }
}
```

## 方法和接口

### 方法

Go没有类，可以在结构体类型上定义方法。方法的接受者出现在func关键字和方法名之间的参数中

可以对包中的任意类型定义任意方法，但是不能对来自其他包的类型或基础类型定义方法

### 接收者为指针的方法

方法可以与命名类型或命名类型的指针关联

使用指针接收者：避免在每个方法调用中拷贝值；方法可以修改接收者指向的值

### 接口

接口类型是由一组方法定义的集合，接口类型的值可以存放实现这些方法的任何值

### 隐式接口

类型通过实现那些方法来实现接口，没有显式声明的必要

隐式接口解耦了实现接口的包和定义接口的包：互不依赖。无需在每个实现上增加新的接口名称

### Stringers

一个普遍存在的接口：fmt包中的Stringer

```Go
type Stringer interface {
    String() string
}
```

Stringer是一个可以用字符串描述自己的类型，fmt包使用其来输出

### 错误（？）

使用error值来表示错误状态，error类型是一个内建接口

```Go
type error interface {
    Error() string
}
```

通常函数会返回一个error值，调用它的代码应当判断这个错误是否等于nil，来进行错误处理

`i, err := strconv.Atoi("42")`

error为nil时表示成功，非nil则表示错误

### Readers（？）

io包指定了io.Reader接口，表示从数据流结尾读取

io.Reader接口有一个Read方法: `func (T) Read(b []byte) (n int, err error)` 用数据填充指定的字节slice，并返回填充的字节数以及错误信息。在遇到数据流结尾时，返回io.EOF错误

### Web服务器

### 图片

## 并发
